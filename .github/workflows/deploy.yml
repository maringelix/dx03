name: üöÄ Deploy Application to GKE

on:
  push:
    branches: [main, master]
    paths:
      - 'client/**'
      - 'server/**'
      - 'k8s/**'
      - '.github/workflows/deploy.yml'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy'
        required: true
        type: choice
        options:
          - dev
          - prod
        default: dev

permissions:
  contents: read
  id-token: write

env:
  GCP_REGION: us-central1
  GKE_CLUSTER: tx03-gke-cluster
  ARTIFACT_REGISTRY: dx03
  NAMESPACE: dx03-dev

jobs:
  build-and-deploy:
    name: Build and Deploy to GKE
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout dx03
        uses: actions/checkout@v4
        with:
          path: app

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ secrets.WIF_PROVIDER }}
          service_account: ${{ secrets.WIF_SERVICE_ACCOUNT }}
          create_credentials_file: true
          export_environment_variables: true

      - name: Setup Cloud SDK
        uses: google-github-actions/setup-gcloud@v2

      - name: Configure Docker for Artifact Registry
        run: |
          echo "üîê Configuring Docker authentication..."
          gcloud auth configure-docker ${{ env.GCP_REGION }}-docker.pkg.dev

      - name: Get GKE Credentials
        run: |
          echo "üîë Getting GKE credentials..."
          gcloud components install gke-gcloud-auth-plugin --quiet
          gcloud container clusters get-credentials ${{ env.GKE_CLUSTER }} \
            --region ${{ env.GCP_REGION }} \
            --project ${{ secrets.GCP_PROJECT_ID }}

      - name: Build and Push Frontend
        working-directory: app/client
        run: |
          echo "üèóÔ∏è Building frontend image..."
          echo "üìÇ Current directory: $(pwd)"
          echo "üìÑ Files:"
          ls -la
          
          docker build \
            --no-cache \
            -t ${{ env.GCP_REGION }}-docker.pkg.dev/${{ secrets.GCP_PROJECT_ID }}/${{ env.ARTIFACT_REGISTRY }}/frontend:${{ github.sha }} \
            -t ${{ env.GCP_REGION }}-docker.pkg.dev/${{ secrets.GCP_PROJECT_ID }}/${{ env.ARTIFACT_REGISTRY }}/frontend:latest \
            .
          
          echo "üì¶ Pushing frontend image..."
          docker push ${{ env.GCP_REGION }}-docker.pkg.dev/${{ secrets.GCP_PROJECT_ID }}/${{ env.ARTIFACT_REGISTRY }}/frontend:${{ github.sha }}
          docker push ${{ env.GCP_REGION }}-docker.pkg.dev/${{ secrets.GCP_PROJECT_ID }}/${{ env.ARTIFACT_REGISTRY }}/frontend:latest
          
          echo "‚úÖ Frontend image pushed successfully!"

      - name: Build and Push Backend
        working-directory: app/server
        run: |
          echo "üèóÔ∏è Building backend image..."
          
          docker build \
            -t ${{ env.GCP_REGION }}-docker.pkg.dev/${{ secrets.GCP_PROJECT_ID }}/${{ env.ARTIFACT_REGISTRY }}/backend:${{ github.sha }} \
            -t ${{ env.GCP_REGION }}-docker.pkg.dev/${{ secrets.GCP_PROJECT_ID }}/${{ env.ARTIFACT_REGISTRY }}/backend:latest \
            .
          
          echo "üì¶ Pushing backend image..."
          docker push ${{ env.GCP_REGION }}-docker.pkg.dev/${{ secrets.GCP_PROJECT_ID }}/${{ env.ARTIFACT_REGISTRY }}/backend:${{ github.sha }}
          docker push ${{ env.GCP_REGION }}-docker.pkg.dev/${{ secrets.GCP_PROJECT_ID }}/${{ env.ARTIFACT_REGISTRY }}/backend:latest
          
          echo "‚úÖ Backend image pushed successfully!"

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.9.0

      - name: Get Database Credentials
        id: db_creds
        run: |
          echo "üîç Using database credentials from secrets..."
          echo "::add-mask::${{ secrets.DB_PASSWORD }}"
          echo "db_password=${{ secrets.DB_PASSWORD }}" >> $GITHUB_OUTPUT
          echo "db_host=${{ secrets.DB_HOST }}" >> $GITHUB_OUTPUT
          echo "‚úÖ Database credentials retrieved"

      - name: Create Kubernetes Namespace
        continue-on-error: true
        run: |
          echo "üìÅ Creating namespace..."
          kubectl create namespace ${{ env.NAMESPACE }} || echo "Namespace already exists"
          kubectl label namespace ${{ env.NAMESPACE }} app=dx03 --overwrite

      - name: Create Database Secret
        run: |
          echo "üîê Creating database secret..."
          
          # Delete existing secret if exists
          kubectl delete secret dx03-db-secret -n ${{ env.NAMESPACE }} --ignore-not-found=true
          
          # Create new secret (matching backend-deployment.yaml keys)
          echo "üîç Creating secret with password length: ${#PASSWORD_VAR}"
          PASSWORD_VAR="${{ steps.db_creds.outputs.db_password }}"
          kubectl create secret generic dx03-db-secret \
            --from-literal=host=${{ steps.db_creds.outputs.db_host }} \
            --from-literal=port=5432 \
            --from-literal=database=dx03 \
            --from-literal=username=dx03 \
            --from-literal=password="$PASSWORD_VAR" \
            --namespace=${{ env.NAMESPACE }}
          
          # Debug: Verify secret keys (values are hidden)
          echo "üîç Verifying secret keys..."
          kubectl get secret dx03-db-secret -n ${{ env.NAMESPACE }} -o jsonpath='{.data}' | jq 'keys'
          
          echo "‚úÖ Database secret created"

      - name: Apply ConfigMap
        working-directory: app
        run: |
          echo "‚öôÔ∏è Applying ConfigMap..."
          
          # Replace environment placeholder
          sed "s|ENVIRONMENT_PLACEHOLDER|dev|g" k8s/configmap.yaml | kubectl apply -f -
          
          echo "‚úÖ ConfigMap applied"

      - name: Deploy Backend
        working-directory: app
        run: |
          echo "üöÄ Deploying backend..."
          
          # Delete old deployments to avoid config errors from old secrets
          kubectl delete deployment dx03-backend -n ${{ env.NAMESPACE }} --ignore-not-found=true
          sleep 10
          
          # Replace placeholders
          sed "s|IMAGE_PLACEHOLDER|${{ env.GCP_REGION }}-docker.pkg.dev/${{ secrets.GCP_PROJECT_ID }}/${{ env.ARTIFACT_REGISTRY }}/backend:${{ github.sha }}|g; s|ENVIRONMENT_PLACEHOLDER|dev|g" k8s/backend-deployment.yaml | kubectl apply -f -
          
          # Apply service (replace placeholder)
          sed "s|ENVIRONMENT_PLACEHOLDER|dev|g" k8s/backend-service.yaml | kubectl apply -f -
          
          echo "‚è≥ Waiting for backend rollout..."
          echo "üìä Checking pod status..."
          kubectl get pods -n ${{ env.NAMESPACE }}
          kubectl describe deployment dx03-backend -n ${{ env.NAMESPACE }} | tail -20
          
          # Show pod details if still pending
          echo "üîç Checking pod events..."
          kubectl get events -n ${{ env.NAMESPACE }} --sort-by='.lastTimestamp' | tail -20
          kubectl describe pods -n ${{ env.NAMESPACE }} -l app=dx03-backend | grep -A 10 "Events:"
          
          # Wait for pods to start and show logs if crashing
          echo "üìã Waiting 30s for pods to start..."
          sleep 30
          echo "üìã Checking pod logs..."
          kubectl logs -n ${{ env.NAMESPACE }} -l app=dx03-backend --tail=100 --all-containers=true --ignore-errors=true || echo "No logs available yet"
          
          kubectl rollout status deployment/dx03-backend -n ${{ env.NAMESPACE }} --timeout=10m
          
          echo "‚úÖ Backend deployed successfully!"

      - name: Deploy Frontend
        working-directory: app
        run: |
          echo "üöÄ Deploying frontend..."
          
          # Replace placeholders
          sed "s|IMAGE_PLACEHOLDER|${{ env.GCP_REGION }}-docker.pkg.dev/${{ secrets.GCP_PROJECT_ID }}/${{ env.ARTIFACT_REGISTRY }}/frontend:${{ github.sha }}|g; s|ENVIRONMENT_PLACEHOLDER|dev|g" k8s/frontend-deployment.yaml | kubectl apply -f -
          
          # Apply service (replace placeholder)
          sed "s|ENVIRONMENT_PLACEHOLDER|dev|g" k8s/frontend-service.yaml | kubectl apply -f -
          
          echo "‚è≥ Waiting for frontend rollout..."
          kubectl rollout status deployment/dx03-frontend -n ${{ env.NAMESPACE }} --timeout=5m
          
          echo "‚úÖ Frontend deployed successfully!"

      - name: Checkout tx03 for Terraform outputs
        uses: actions/checkout@v4
        with:
          repository: maringelix/tx03
          path: tx03
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Terraform for tx03
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.9.0
          terraform_wrapper: false

      - name: Initialize Terraform state
        working-directory: tx03/terraform/environments/dev
        run: |
          echo "üîß Initializing Terraform..."
          terraform init

      - name: Apply ManagedCertificate
        working-directory: app
        run: |
          echo "üîê Applying ManagedCertificate for SSL..."
          sed "s|ENVIRONMENT_PLACEHOLDER|${{ env.NAMESPACE }}|g" k8s/managed-certificate.yaml | kubectl apply -f -
          
          echo "‚úÖ ManagedCertificate applied!"

      - name: Apply FrontendConfig (HTTPS Redirect)
        working-directory: app
        run: |
          echo "üîí Applying FrontendConfig for HTTPS redirect..."
          sed "s|ENVIRONMENT_PLACEHOLDER|${{ env.NAMESPACE }}|g" k8s/frontend-config.yaml | kubectl apply -f -
          
          echo "‚úÖ FrontendConfig applied - HTTP will redirect to HTTPS!"

      - name: Apply Ingress
        run: |
          echo "üåê Applying Ingress with static IP..."
          
          # Get static IP name and SSL certificate from Terraform output
          cd tx03/terraform/environments/dev
          STATIC_IP_NAME=$(terraform output -raw loadbalancer_static_ip_name 2>/dev/null || echo "")
          SSL_CERT_NAME=$(terraform output -raw loadbalancer_ssl_certificate_name 2>/dev/null || echo "")
          cd -
          
          # Build annotations based on available resources
          ANNOTATIONS='kubernetes.io/ingress.class: "gce"
              cloud.google.com/neg: '\''{"ingress": true}'\'''
          
          if [ -n "$STATIC_IP_NAME" ]; then
            echo "‚úÖ Using static IP: $STATIC_IP_NAME"
            ANNOTATIONS="$ANNOTATIONS"'
              kubernetes.io/ingress.global-static-ip-name: "'"$STATIC_IP_NAME"'"'
          else
            echo "‚ö†Ô∏è No static IP found, Load Balancer will use ephemeral IP"
          fi
          
          if [ -n "$SSL_CERT_NAME" ]; then
            echo "üîê Using SSL certificate: $SSL_CERT_NAME"
            ANNOTATIONS="$ANNOTATIONS"'
              networking.gke.io/managed-certificates: "'"$SSL_CERT_NAME"'"'
          else
            echo "‚ö†Ô∏è No SSL certificate found, will use HTTP only"
          fi
          
          # Create Ingress with dynamic annotations
          cat <<EOF | kubectl apply -f -
          apiVersion: networking.k8s.io/v1
          kind: Ingress
          metadata:
            name: dx03-ingress
            namespace: ${{ env.NAMESPACE }}
            annotations:
              $ANNOTATIONS
          spec:
            rules:
            - http:
                paths:
                - path: /api
                  pathType: Prefix
                  backend:
                    service:
                      name: dx03-backend
                      port:
                        number: 80
                - path: /health
                  pathType: Prefix
                  backend:
                    service:
                      name: dx03-backend
                      port:
                        number: 80
                - path: /
                  pathType: Prefix
                  backend:
                    service:
                      name: dx03-frontend
                      port:
                        number: 80
          EOF
          
          echo "‚úÖ Ingress applied!"

      - name: Get Application URLs
        id: urls
        continue-on-error: true  # Don't fail if LB not ready yet
        run: |
          echo "üîç Getting application URLs..."
          
          # Wait up to 10 minutes for ingress to get IP (GCP LB provisioning can take time)
          echo "‚è≥ Waiting for Load Balancer IP (this can take 5-15 minutes)..."
          for i in {1..60}; do
            INGRESS_IP=$(kubectl get ingress dx03-ingress -n ${{ env.NAMESPACE }} -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "")
            if [ -n "$INGRESS_IP" ]; then
              echo "ingress_ip=$INGRESS_IP" >> $GITHUB_OUTPUT
              echo "üåê Ingress IP: $INGRESS_IP"
              break
            fi
            
            # Show progress every 30 seconds
            if [ $((i % 3)) -eq 0 ]; then
              echo "‚è≥ Still waiting... ($i/60 = $((i * 10 / 60)) minutes elapsed)"
            fi
            sleep 10
          done
          
          if [ -z "$INGRESS_IP" ]; then
            echo "‚ö†Ô∏è  Ingress IP not assigned within 10 minutes"
            echo "‚ÑπÔ∏è  This is normal for first deployment - Load Balancer is still provisioning"
            echo "üí° Check status in a few minutes with:"
            echo "   kubectl get ingress dx03-ingress -n ${{ env.NAMESPACE }}"
          fi

      - name: Check Backend Logs
        run: |
          echo "üìã Checking backend logs for errors..."
          echo "======================================"
          
          # Get backend pod name
          BACKEND_POD=$(kubectl get pods -n ${{ env.NAMESPACE }} -l app=dx03-backend -o jsonpath='{.items[0].metadata.name}')
          
          if [ -n "$BACKEND_POD" ]; then
            echo "üì¶ Backend Pod: $BACKEND_POD"
            echo ""
            echo "üìù Recent logs:"
            kubectl logs $BACKEND_POD -n ${{ env.NAMESPACE }} --tail=50 || echo "‚ö†Ô∏è  Could not fetch logs"
            echo ""
            
            # Check for database connection errors
            echo "üîç Checking for database errors..."
            kubectl logs $BACKEND_POD -n ${{ env.NAMESPACE }} --tail=100 | grep -i "error\|failed\|database\|connection" || echo "‚úÖ No obvious errors found"
          else
            echo "‚ö†Ô∏è  No backend pod found"
          fi

      - name: Associate Cloud Armor WAF
        continue-on-error: true
        run: |
          echo "üõ°Ô∏è Associating Cloud Armor WAF with backend services..."
          
          # Get backend service names
          BACKEND_SERVICES=$(gcloud compute backend-services list --filter="name~dx03-dev" --format="value(name)")
          
          if [ -z "$BACKEND_SERVICES" ]; then
            echo "‚ö†Ô∏è  No backend services found yet (Load Balancer still provisioning)"
            exit 0
          fi
          
          # Associate WAF policy with each backend service
          for service in $BACKEND_SERVICES; do
            echo "üîß Associating WAF with: $service"
            gcloud compute backend-services update $service \
              --security-policy=tx03-waf-policy \
              --global \
              || echo "‚ö†Ô∏è  Could not associate WAF with $service (might not exist yet)"
          done
          
          echo "‚úÖ Cloud Armor WAF association complete!"

      - name: Test Endpoints
        id: test
        continue-on-error: true
        run: |
          echo "üß™ Testing application endpoints..."
          
          INGRESS_IP="${{ steps.urls.outputs.ingress_ip }}"
          
          if [ -z "$INGRESS_IP" ]; then
            echo "‚è≥ Load Balancer IP not available yet, skipping tests"
            exit 0
          fi
          
          echo "üåê Testing: http://$INGRESS_IP"
          echo ""
          
          # Test frontend
          echo "1Ô∏è‚É£ Frontend (/):"
          FRONTEND_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "http://$INGRESS_IP/" --max-time 10) || FRONTEND_STATUS="timeout"
          echo "   Status: $FRONTEND_STATUS"
          [ "$FRONTEND_STATUS" = "200" ] && echo "   ‚úÖ OK" || echo "   ‚ùå FAILED"
          echo ""
          
          # Test backend root
          echo "2Ô∏è‚É£ Backend Root (/api):"
          BACKEND_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "http://$INGRESS_IP/api" --max-time 10) || BACKEND_STATUS="timeout"
          echo "   Status: $BACKEND_STATUS"
          [ "$BACKEND_STATUS" = "200" ] && echo "   ‚úÖ OK" || echo "   ‚ùå FAILED"
          echo ""
          
          # Test health check
          echo "3Ô∏è‚É£ Health Check (/health/live):"
          HEALTH_RESPONSE=$(curl -s "http://$INGRESS_IP/health/live" --max-time 10) || HEALTH_RESPONSE="timeout"
          HEALTH_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "http://$INGRESS_IP/health/live" --max-time 10) || HEALTH_STATUS="timeout"
          echo "   Status: $HEALTH_STATUS"
          echo "   Response: $HEALTH_RESPONSE"
          [ "$HEALTH_STATUS" = "200" ] && echo "   ‚úÖ OK" || echo "   ‚ùå FAILED"

      - name: Deployment Summary
        run: |
          echo "üìä Deployment Summary"
          echo "===================="
          echo ""
          echo "üéØ Environment: dev"
          echo "üì¶ Namespace: ${{ env.NAMESPACE }}"
          echo ""
          echo "üê≥ Images:"
          echo "  Frontend: us-central1-docker.pkg.dev/${{ secrets.GCP_PROJECT_ID }}/dx03/frontend:${{ github.sha }}"
          echo "  Backend:  us-central1-docker.pkg.dev/${{ secrets.GCP_PROJECT_ID }}/dx03/backend:${{ github.sha }}"
          echo ""
          echo "üîó Services:"
          kubectl get svc -n ${{ env.NAMESPACE }}
          echo ""
          echo "üöÄ Deployments:"
          kubectl get deployments -n ${{ env.NAMESPACE }}
          echo ""
          echo "üì¶ Pods:"
          kubectl get pods -n ${{ env.NAMESPACE }}
          echo ""
          echo "üîß Ingress:"
          kubectl get ingress -n ${{ env.NAMESPACE }}
          echo ""
          if [ -n "${{ steps.urls.outputs.ingress_ip }}" ]; then
            echo "‚úÖ Application is ready!"
            echo "üåê Frontend URL: http://${{ steps.urls.outputs.ingress_ip }}"
            echo "üåê Backend API: http://${{ steps.urls.outputs.ingress_ip }}/api"
            echo "üè• Health Check: http://${{ steps.urls.outputs.ingress_ip }}/health/live"
            echo ""
            echo "üõ°Ô∏è Cloud Armor WAF: Configured"
          else
            echo "‚è≥ Load Balancer still provisioning (takes 5-15 minutes)"
            echo ""
            echo "üìã To check status:"
            echo "   kubectl get ingress dx03-ingress -n ${{ env.NAMESPACE }}"
            echo ""
            echo "üìã Once IP is assigned, access:"
            echo "   Frontend: http://<INGRESS_IP>"
            echo "   Backend:  http://<INGRESS_IP>/api"
            echo "   Health:   http://<INGRESS_IP>/api/health/live"
          fi

  notify-success:
    name: Notify Success
    runs-on: ubuntu-latest
    needs: build-and-deploy
    if: success()
    steps:
      - name: Success notification
        run: |
          echo "‚úÖ Application deployed successfully!"
          echo "üéâ All services are running"

  notify-failure:
    name: Notify Failure
    runs-on: ubuntu-latest
    needs: build-and-deploy
    if: failure()
    steps:
      - name: Failure notification
        run: |
          echo "‚ùå Application deployment failed!"
          echo "üîó Check logs: https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          exit 1
